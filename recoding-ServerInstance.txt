'''
Created on Aug 5, 2011

@author: marius
'''
    def SendDelta(self, idRev, sentdelta, binchksum = None, size = 'NULL'):
        """Send delta to server"""        
        tsnow = datetime.now()
        # get real checksum
        try:
            chksum = int.from_bytes( binchksum.data , byteorder='big' )
        except AttributeError:
            chksum = 'NULL'
        
        self._logger.debug("Receiving delta, now()=%s" , repr(tsnow) )
        self._logger.debug("Chksum received: %s" , repr(chksum) )
        #check if everything is ok
        with self._conn as c:
            self._logger.debug ( "Getting row of revisions . . ." )
            rowRev = c.execute ( "select * from revisions where idrev=?" ,(idRev,)).fetchone()
            self._logger.debug ( "Getting row of file information . . ." )
            rowFile = c.execute ( "select * from files where idfile=?" ,
                (rowRev['idfile'],) ).fetchone()
            if rowFile['lastrev'] != idRev:
                self._logger.info("Error: Outdated client")
                return ERR_OUTDATED                
            if rowFile['deleted'] == 1:
                self._logger.info("Error: file in deleted state")
                return ERR_DELETED
            
            self._logger.debug ( "Inserting new revision into database . . ." )
            try:
                cur = c.execute ( '''insert into revisions 
                    (idfile, timestamp, fromrev, typefrom, chksum, size, hardexist) values
                    (?,?,?,?,?,?,0)''' , (rowRev['idfile'], tsnow , idRev, REV_MODIFIED,chksum, size ) )
                
                nextRev = cur.lastrowid
            
                c.execute ( '''update files set lastrev=? where idfile=?''' ,
                    (nextRev , rowRev['idfile'] ) )
            except:
                raise
                return ERR_SQL
        
        self._logger.debug ( "Going to write the delta file" )
        #now, save the delta
        delta = Deltas.load(sentdelta)
        delta.save(os.path.join(self._deltasdir,str(nextRev)))
        
        self._logger.debug ( "Latest revision: %s" , int(nextRev) )
        return nextRev, tsnow
    
    def getDeltasSinceEvent ( self, eventType , condition , startRev ):
        """Get all the deltas since a given "event" (sqlite column)
        The row that satisfies the condition is NOT added to the list
        (be careful with idrev vs fromrev)
        Return the best error code if something goes wrong
        """
        # thinking in yield-ing... but if there is an error, 
        # then everything would seem more awkward
        # Maybe is more pytonic, and raise when needed
        deltaHistory = [ startRev ]
        with self._conn as c:
            revRow = c.execute ( '''select * from revisions
                where idrev=?''' , (startRev,) ).fetchone()
            while revRow[eventType] != condition:
                revRow = c.execute ( '''select * from revisions 
                    where idrev=?''' , 
                    (revRow['fromrev'],) ).fetchone()
                if not revRow:
                    # asking for impossible connexion
                    return ERR_CANNOT
                    
                self._logger.debug ( 'This row %s has %s in %s' , 
                    str(revRow['idrev']) , str(revRow[eventType]) , 
                    eventType )
                    
                deltaHistory.append( revRow['idrev'] )
        return deltaHistory
        
    def GetDelta(self, idRev, idFromRev):
        """Get delta (see rsync algorithm) to jump between two revisions"""
        
        #if it's the easy way, we do it the easy way (most likely to hapen)
        with self._conn as c:
            revRow = c.execute( "select * from revisions where idrev=?" , idRev).fetchone()
        
        if (revRow['fromrev'] == idFromRev) and (revRow['fromtype'] == REV_MODIFIED):
            #yes, we are lucky!
            try:
                delta = Deltas.open(os.path.join(self._deltasdir,str(idRev)))
            except:
                delta = ERR_FS
            return delta.getXMLRPCBinary()
        else:
            if revRow['fromtype'] != REV_MODIFIED:
                # asking for an inexistant delta 
                return ERR_CANNOT
              
            # 1st: check that exists a chain of non-deletions between 
            # this two revisions (save the first hardcopy for later)
            deltaList = self.getDeltasSinceEvent ( 'idrev' , idFromRev , idRev )
            if type(deltaList) == int:
                return deltaList
                
            # 2nd: try to join everything
            try:
                val = deltaList.pop()
                self._logger.debug ( "Getting delta for %s" , str(val) )
                delta = Deltas.open(os.path.join(self._deltasdir, str(val)))
                while deltaList:
                    filename = os.path.join(self._deltasdir, str(deltaList.pop()))
                    delta.joinDelta ( Deltas.open(filename) )
            except:
                return ERR_FS
                    
            # 3rd: Send delta
            return delta.getXMLRPCBinary()

    def GetMetaInfo ( self, rev , force=False):
        """Get the metainfo (actually size and chksum) of some revision
        
        force = True if want to get this values (a hard copy will be done
        if necessary). If not forced, -1 values will be returned if no 
        hard copy exists)
        """
        
        pass
        
    def GetLastRev(self, filepath):
        """Get the id of the last revision of some file
        Get it by the identificator of """
        with self._conn as c:
            row = c.execute ( '''select lastrev from files
                where path=?''' , (filepath,) ).fetchone()
        if row == None:
            return ERR_NOTEXIST
        return row['lastrev']
        
    def MakeDir (self, path ):
        """Create directory ``path''"""
        return ERR_TODO
    
    
        
    def GetFullRevision ( self, idRev ):
        """Get a file by its revision identificator (not necessarily
        the most actual version of the file)"""
        
        self._logger.info( 'Getting full revision for %s' , str(idRev) )
        
        with self._conn as c:
            row = c.execute ('''select * from revisions where
                idrev=?''' , (idRev,) ).fetchone()
            
            #check if it can be the easy way
            if row['hardexist'] != 1:
                self._logger.debug ( 'Doing it the hard way' )
                # hard way, let's build the hard copy
                # search for last hard copy first
                deltaList = self.getDeltasSinceEvent ( 'hardexist' , 1 , idRev )
                self._logger.debug ( "(in GetFullRevision) Variable deltaList received: %s" , repr(deltaList) )
                if type(deltaList) == int:
                    self._logger.debug ( "deltaList is a int")
                    return deltaList
                
                # join everything
                #first throw away this, but save for later
                hardRev = deltaList.pop()
                self._logger.debug ( "Getting delta" )
                try:
                    val = str(deltaList.pop())
                    self._logger.debug ( "  - First: %s" , val )
                    delta = Deltas.open(os.path.join(self._deltasdir, val))
                    while deltaList:
                        val = str(deltaList.pop())
                        filename = os.path.join(self._deltasdir, val)
                        self._logger.debug ( "  - Now adding %s, at %s" , val, filename )
                        delta.join (Deltas.open(filename))
                except:
                    raise
                    return ERR_FS
                
                self._logger.debug ( "Empty deltalist, last value: %s" , str(val) )
                
                # the last one, now will have hardcopy
                c.execute ( '''update revisions set hardexist=1
                    where idrev=?''' , (idRev,) )
                
                # this line, saved from
                row = c.execute ( '''select * from revisions 
                    where idrev=?''' , (hardRev,) ).fetchone()
                
                self._logger.info ( "Creating hard revision %s from revision %s" ,
                    idRev , hardRev )
                
                infile =  os.path.join(self._hardsdir,str(row['idrev']))
                outfile = os.path.join(self._hardsdir,str(val))
                delta.patch(infile, outfile)
        
        self._logger.debug ( 'Sending hard revision to client' )
        
        with open ( os.path.join ( self._hardsdir , str(idRev) ) , "rb" ) as f:
            data = Binary ( f.read() )
        return data
